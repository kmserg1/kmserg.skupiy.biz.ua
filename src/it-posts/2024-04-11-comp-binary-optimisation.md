---
title: Бінарна оптимізація програм
tags: [ "ідея" ]
---

## Передумови 

Весь розвиток язиків програмування спрямований на полегшення програмування для людини. Це велике обмеження.

Людина має обмежену пам'ять і обмежену кількіть об'єктів, які може тримати в полі зору (чи полі уваги) одночасно. Людині складно контролювати велику кількість зв'язків. 
Людина не може передбачити наслідки своїх дій, хоча б на рівні програми.

Для прикладу: в авіації експериментальним шляхом дійшли до обмеження у максимально сім параметрів, які повинен однчасно контролювати пілот. Якщо більше - то аварія.

Тому язики програмування спрямовані на те, щоб дати можливість людині якось писати складні програми з урахуванням обмежень людського мозку.

Щоб людина оперувала одночасно невеликою кількістю сутностей, у мовах програмування вводяться складні концепції, як от об'єтно орієнтоване програмування та інші.
Цим забезпечується відносний контроль і безпека кода.
Але при цьому програма обростає шарами службового коду, основна задача якого - бути запобіжнком від людських помилок, і  який не потрібен для виконання основної задачі.
Відповідно росте розмір і падає швидкість виконання.

## Ідея

На відміну від людини комп'ютер не має вищевказаних обмежень. Комп'ютер легко може оперувати сотнями тисяч і мільйонами сутностей одночасно. У нього нема обмежеть по пам'яті (хоча б у людському сенсі).
Тому для комп'ютера всі ці запобіжники не потрібні. Якщо буде машинний інтелект, достатньо могутній, шоб врахувати всі побічні ефекти, 
то можливо обійтися без запобіжників, як от безпечні вказівники, збірка мусора, заборона goto и т.д.

Можна відмовитися від складних концепцій типу класів, наслідування, шаблонів класів і т.д. і для кожної задачі створювати і використовувати оптимальні типи даних 
і оптимальну їх обробку.

Комп'ютер може програмувати на асемблері чи навіть в машинних кодах.

Таким чином можна наблизитися до теоретичного максимуму швидкості комп'ютерних програм і навіть на сьогодняшніх комп'ютерах досягти того, чого ми зараз не можемо уявити.
Можна назвати такі програми бінарно оптимізованими (Binary Optimized Programs - BOP). 

### При цьому виникає декілька питань.

#### Перше - питання контролю.

Як ми можемо перевірити, наскільки вірно програма виконує свої функції? 

Тут не видно легкого рішення. Можна спробувати методи, якими перевіряють справність складної електроніки, як от процесорів з сотнями входів/виходів, мільойнами транзисторів і кількістю внутрішніх станів більшою ніж атомів у всесвіті.
Наскільки я пам'ятаю, один з методів - це перевірка контрольних точок у місцях, де інформаційна ентропія мінімальна.
Щось аналогічне можна спробувати і для програм.
Напевно є багато і інших методів контролю, і їх можна спробувати адаптувати для таких програм. В будь-якому випадку це серйозна і складна наука.

#### Друге питання - постановка задачі.

Якщо досить детально описувати задачу на якійсь формалізованій мові, то це може перетворитися на написання програми для цієї задачі людиною, по якій потім машина буде створювати свою (оптимальну) програму.
Якщо ж обмежитися загальною постановкою задачі на людській мові і довіритися штучному інтелекту, то тоді ми навіть не зможемо бути впевненими, що машина робила програму 
для нашої задачі, а не для якоїсь іншої. І тоді ми повертаємось до першого питання.


Можна також спробувати оптимізувати наявні програми. Тут у комп'ютера буде завдання діти до суті задачі, звільнити код від запобіжних шарів, можливо змінити алгоритм.

## Можливі наслідки

Від BOP-програм можна чекати набагато меншого розміру і набагато більшої швидкості виконання. Тому:

- Вони зможуть легко виконуватись на невеликих і слабких комп'ютерах. Враховуючи тенденції мініатюризації це може бути шагом до розумного довкілля, як у Станіслава Лема у "Футурологічному конгресі".
- На звичайних комп'ютерах можна буде вирішувти задачі, які зараз виконуються на суперкомп'ютерах
- Суперкомп'ютери зможуть вирішувти задачі, які зараз неможливо вірішити.